# Usando JNI para fazer Java e Assembly conversarem

Ol√°, amantes da programa√ß√£o! üöÄ

J√° se perguntaram como fazer seu c√≥digo Java ‚Äúconversar‚Äù diretamente com Assembly, especialmente no nov√≠ssimo ARM64 dos Macs M1? Ent√£o, sente-se, pegue um caf√© (ou ch√°, se preferir), porque vou te mostrar exatamente como fazer isso usando o Java Native Interface (JNI).

## 1. O que √© JNI?
Em resumo, JNI (Java Native Interface) √© uma interface de programa√ß√£o que permite que o c√≥digo Java interaja com programas escritos em outras linguagens, como C, C++ e, no nosso caso, Assembly.

## 2. Preparando o Terreno
Primeiro, voc√™ precisa ter o JDK instalado. Se n√£o tiver, corra l√° e instale!

## 3. Nosso Programa Java
Vamos come√ßar criando uma classe Java simples que invocar√° um m√©todo nativo. Chamaremos essa classe de ConversorMaiuscula. Salve o c√≥digo abaixo como `ConversorMaiuscula.java`

```
public class ConversorMaiuscula {
    static {
        System.loadLibrary("maiuscula");
    }

    public native String paraMaiuscula(String texto);

    public static void main(String[] args) {
        ConversorMaiuscula conversor = new ConversorMaiuscula();
        String original = "Hello World!";
        String maiuscula = conversor.paraMaiuscula(original);

        System.out.println("Original: " + original);
        System.out.println("Mai√∫scula: " + maiuscula);
    }
}
```
## 4. C√≥digo Assembly
Agora precisamos implementar uma fun√ß√£o que converte uma string para mai√∫sculas, usando assembly ARM64 (sim, aquele dos novos Macs M1) . Chamaremos esta fun√ß√£o de `converter_para_maiuscula`. Salve o c√≥digo abaixo como `conversormaiuscula.asm`

```
.section __TEXT, __text
.globl _converter_para_maiuscula
.align 4

_converter_para_maiuscula:
    stp     x29, x30, [sp, #-16] ; Prepara o stack frame.
    mov     x29, sp

processa_caractere:
    ldrb    w2, [x0]             ; Carrega o pr√≥ximo byte (caractere) da string em w2.
    cbz     w2, termina          ; Se encontramos o byte nulo (final da string), terminamos.

    cmp     w2, #'a'             ; Verifica se o caractere √© menor que 'a' (ou seja, n√£o √© uma letra min√∫scula).
    blo     nao_e_minusculo      ; Se sim, pula a convers√£o.

    cmp     w2, #'z'             ; Verifica se o caractere √© maior que 'z' (ou seja, n√£o √© uma letra min√∫scula).
    bhi     nao_e_minusculo      ; Se sim, pula a convers√£o.

    
    sub     w2, w2, #('a' - 'A') ; Converte a letra min√∫scula em mai√∫scula.
    strb    w2, [x0]             ; Armazena o caractere convertido de volta na string.

nao_e_minusculo:
    add     x0, x0, #1           ; Move para o pr√≥ximo caractere na string.
    b       processa_caractere

termina:
    ldp     x29, x30, [sp], #16  ; Restaura o stack frame.
    ret
```

## 5. Ponte JNI
Vamos criar nosso c√≥digo em C que atuar√° como uma ‚Äúponte‚Äù entre Java e Assembly usando JNI. Esse c√≥digo ir√° virar uma biblioteca din√¢mica (.dylib). Salve o c√≥digo abaixo como `conversormaiusculaJNI.c`. O c√≥digo ficar√° assim:
```
#include <jni.h>
#include "ConversorMaiuscula.h"

extern void converter_para_maiuscula(const char* entrada);

JNIEXPORT jstring JNICALL Java_ConversorMaiuscula_paraMaiuscula(JNIEnv *env, jobject obj, jstring textoJava) {
    const char* entrada = (*env)->GetStringUTFChars(env, textoJava, NULL);

    converter_para_maiuscula(entrada);

    jstring resultado = (*env)->NewStringUTF(env, entrada);

    (*env)->ReleaseStringUTFChars(env, textoJava, entrada);
    return resultado;
}
```
## 6. Compilando e Rodando
Agora vem a parte divertida (e um pouco complicada)! Precisamos compilar e vincular tudo.

### 1.Compile o c√≥digo Java:
`javac ConversorMaiuscula.java`

### 2. Compile o c√≥digo assembly:
`as -o conversormaiuscula.o conversormaiuscula.asm`

### 3. Gere o cabe√ßalho JNI:
`javac -h . ConversorMaiuscula.java`

Esse passo gera o arquivo `ConversorMaiuscula.h` com o prot√≥tipo da nossa fun√ß√£o. O conte√∫do do arquivo ser√°:
```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class ConversorMaiuscula */

#ifndef _Included_ConversorMaiuscula
#define _Included_ConversorMaiuscula
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     ConversorMaiuscula
 * Method:    paraMaiuscula
 * Signature: (Ljava/lang/String;)Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_ConversorMaiuscula_paraMaiuscula
  (JNIEnv *, jobject, jstring);

#ifdef __cplusplus
}
#endif
#endif
```

### 4. Compile e vincule (link) o c√≥digo C JNI e o objeto gerado pelo c√≥digo Assembly, gerando nossa biblioteca din√¢mica:
`gcc -dynamiclib -o libmaiuscula.dylib -I$JAVA_HOME/include -I$JAVA_HOME/include/darwin ConversorMaiusculaJNI.c conversormaiuscula.o`

### 5. Execute o programa Java:
`java -Djava.library.path=. ConversorMaiuscula`

E a√≠ est√°! Voc√™ acabou de criar um programa Java que invoca c√≥digo Assembly no ARM64!

Todo o c√≥digo est√° no meu github: https://github.com/jluizpjr/JNI-ARM64

## Conclus√£o
Integrar Java com Assembly atrav√©s do JNI pode parecer um pouco ‚Äúnerd demais‚Äù, mas √© super legal e poderoso! Se voc√™ mergulhar mais profundamente, ver√° que as possibilidades s√£o infinitas. Ent√£o v√° em frente, experimente, quebre coisas, conserte-as e continue codificando!

Gostou do tutorial? Deixe seu üëè e compartilhe com seus amigos! At√© a pr√≥xima aventura de c√≥digo! üíªüéâ
